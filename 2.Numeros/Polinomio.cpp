#include "Polinomio.h"
/** Operador referencia a
 * Una referencia es un nombre alternativo (un sin\'onimo) para 
 * un objeto. Su utilizaci\'on la podemos observar en el dise\~no
 * de clases (por ejemplo, en el constructor de copia), en el valor 
 * retornado por una funci\'on para permitir que dicha funci\'on sea 
 * utilizada a ambos lados del operador de asignaci\'on (la funci\'on 
 * devuelve una referencia), o para permitir que los argumentosen la 
 * llamada puedan cambiar (paso de par\'ametros por referencia). La 
 * forma general de expresar una referencia es:
 * tipo& referencia=variable
 */



Polinomio& Polinomio::operator+(Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B45 begin
{
	int grad=maximo(grado,PolObj.grado);
	Polinomio ResP(grad,new Rac[grad+1]);
	Polinomio& ResPol=ResP;
	if(grado==grad){/*si el obj implicito es el de mayor grado*/
		for(int i=0;i<grado+1;i++){
			(ResPol.A+i)->n=(A+i)->n;
			(ResPol.A+i)->d=(A+i)->d;
		}
	}else{/*si el segundo operando es el de mayor grado*/
		for(int i=0;i<PolObj.grado+1;i++){
			(ResPol.A+i)->n=(PolObj.A+i)->n;
			(ResPol.A+i)->d=(PolObj.A+i)->d;
		}
	}
	if(grado<=grad){/*si el objeto implicito es el polinomio de menor grado*/
		for(int i=0;i<grado+1;i++){
			*(ResPol.A+i)=*(ResPol.A+i)+*(PolObj.A+i);
		}
	}else{/*si el segundo operando es el de menor grado*/
		for(int i=0;i<ResPol.grado+1;i++){
			*(ResPol.A+i)=*(ResPol.A+i)+*(A+i);
		}
	}
	return ResPol;
}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B45 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

Polinomio& Polinomio::operator-(Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B48 begin
{
	int grad=maximo(grado,PolObj.grado);
	Polinomio ResP(grad,new Rac[grad+1]);
	Polinomio& ResPol=ResP;
	if(grado==grad){/*si el obj implicito es el de mayor grado*/
		for(int i=0;i<grado+1;i++){
			(ResPol.A+i)->n=(A+i)->n;
			(ResPol.A+i)->d=(A+i)->d;
		}
	}else{/*si el segundo operando es el de mayor grado*/
		for(int i=0;i<PolObj.grado+1;i++){
			(ResPol.A+i)->n=(PolObj.A+i)->n;
			(ResPol.A+i)->d=(PolObj.A+i)->d;
		}
	}
	if(grado<=grad){/*si el objeto implicito es el polinomio de menor grado*/
		for(int i=0;i<grado+1;i++){
			*(ResPol.A+i)=*(ResPol.A+i)-*(PolObj.A+i);
		}
	}else{/*si el segundo operando es el de menor grado*/
		for(int i=0;i<ResPol.grado+1;i++){
			*(ResPol.A+i)=*(ResPol.A+i)-*(A+i);
		}
	}
	return ResPol;
}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B48 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

Polinomio& Polinomio::operator*(Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B4B begin
{
	int grad=grado+PolObj.grado;
	Polinomio ResP(grad,new Rac[grad+1]);
	Polinomio& ResPol=ResP;		/* ResultPolynomial */
	Rac factor1,factor2,factor1porfactor2,sumaparcial;
	for(int i=0;i<ResPol.grado+1;i++){
		*(ResPol.A+i)=Rac(0,1);	/* All coeffs of ResPol must be initialized  to \frac{0}{1} */
	}
	for(int k=0;k<grad+1;k++){
		for(int i=0;i<grado+1;i++){
			for(int j=0;j<PolObj.grado+1;j++){
				if((grado-i+PolObj.grado-j)==grad-k){
					factor1=*(A+i);
					factor2=*(new Rac((PolObj.A+j)->n,(PolObj.A+j)->d));
					factor1porfactor2=factor1*factor2;
					sumaparcial=*(ResPol.A+k)+factor1porfactor2;
					*(ResPol.A+k)=sumaparcial;
				}
			}
		}
	}
	return ResPol;
}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B4B end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

//FcnDTrans& Polinomio::operator/(Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B4F begin
//{
//}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B4F end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

ostream&  operator<<(ostream& ostreamOut, Polinomio& PolObj)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B52 begin
{
 for(int i=0;i<PolObj.grado+1;i++){
 	if((PolObj.A+i)->d==1){
 		ostreamOut<<"\t"<<(PolObj.A+i)->n;
	 }else{
	 	ostreamOut<<"\t"<<(PolObj.A+i)->n<<"/"<<(PolObj.A+i)->d;
	 }
  }
  return ostreamOut;
}
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B52 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

Polinomio::Polinomio(int intGrado, Rac * RacPt):grado(intGrado),A(RacPt)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B56 begin
{ }
// section -64--88-56-1-177a48e9:16187dad081:-8000:0000000000000B56 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element
